<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="LatticeArc - Post-Quantum Cryptography Library"><title>latticearc - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="latticearc" data-themes="" data-resource-suffix="" data-rustdoc-version="1.93.1 (01f6ddf75 2026-02-11)" data-channel="1.93.1" data-search-js="search-9e2438ea.js" data-stringdex-js="stringdex-a3946164.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-a410ff4d.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate latticearc</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../latticearc/index.html">latticearc</a><span class="version">0.3.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#why-latticearc" title="Why LatticeArc?">Why LatticeArc?</a></li><li><a href="#algorithm-validation-status" title="Algorithm Validation Status">Algorithm Validation Status</a></li><li><a href="#unified-api-with-cryptoconfig" title="Unified API with CryptoConfig">Unified API with CryptoConfig</a><ul><li><a href="#basic-usage-hybrid--recommended" title="Basic Usage (Hybrid — Recommended)">Basic Usage (Hybrid — Recommended)</a></li></ul></li><li><a href="#digital-signatures" title="Digital Signatures">Digital Signatures</a></li><li><a href="#feature-flags" title="Feature Flags">Feature Flags</a></li><li><a href="#more-examples" title="More Examples">More Examples</a><ul><li><a href="#symmetric-encryption" title="Symmetric Encryption">Symmetric Encryption</a></li><li><a href="#with-use-case-selection" title="With Use Case Selection">With Use Case Selection</a></li><li><a href="#zero-trust-session-verification" title="Zero Trust Session Verification">Zero Trust Session Verification</a></li><li><a href="#hybrid-encryption-ml-kem-768--x25519" title="Hybrid Encryption (ML-KEM-768 + X25519)">Hybrid Encryption (ML-KEM-768 + X25519)</a></li><li><a href="#hybrid-signatures-ml-dsa-65--ed25519" title="Hybrid Signatures (ML-DSA-65 + Ed25519)">Hybrid Signatures (ML-DSA-65 + Ed25519)</a></li><li><a href="#session-lifecycle" title="Session Lifecycle">Session Lifecycle</a></li><li><a href="#complete-example" title="Complete Example">Complete Example</a></li></ul></li></ul><h3><a href="#reexports">Crate Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#modules" title="Modules">Modules</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>latticearc</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/latticearc/lib.rs.html#4-482">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>LatticeArc - Post-Quantum Cryptography Library</p>
<p>Production-ready post-quantum cryptography. Hybrid ML-KEM+X25519 by default,
all 4 NIST standards (FIPS 203–206), post-quantum TLS, and FIPS 140-3 backend
— one crate, zero unsafe.</p>
<blockquote>
<p><strong>IMPORTANT</strong>: LatticeArc is NOT FIPS 140-3 certified. Only the aws-lc-rs
backend algorithms (ML-KEM, AES-GCM, HKDF, SHA-2) run through a FIPS 140-3
validated module. ML-DSA (fips204), SLH-DSA (fips205), and FN-DSA (fn-dsa)
implement NIST-standard algorithms but use non-validated crate implementations.
Use <code>--features fips</code> to enable the validated aws-lc-rs backend.</p>
</blockquote>
<h3 id="why-latticearc"><a class="doc-anchor" href="#why-latticearc">§</a>Why LatticeArc?</h3><div><table><thead><tr><th>Without LatticeArc</th><th>With LatticeArc</th></tr></thead><tbody>
<tr><td>~50 lines for hybrid encrypt</td><td>3 lines</td></tr>
<tr><td>Manage 4 key vectors manually</td><td>Single <a href="types/crypto_types/enum.EncryptKey.html#variant.Hybrid" title="variant latticearc::types::crypto_types::EncryptKey::Hybrid"><code>EncryptKey::Hybrid</code></a></td></tr>
<tr><td>Research NIST parameter sets</td><td><a href="types/types/enum.UseCase.html" title="enum latticearc::types::types::UseCase"><code>UseCase</code></a> auto-selects</td></tr>
<tr><td>Manual secret zeroization</td><td>Automatic via <code>Zeroize</code></td></tr>
</tbody></table>
</div><h3 id="algorithm-validation-status"><a class="doc-anchor" href="#algorithm-validation-status">§</a>Algorithm Validation Status</h3><div><table><thead><tr><th>Algorithm</th><th>Standard</th><th>Backend</th><th>FIPS Validated</th></tr></thead><tbody>
<tr><td>ML-KEM</td><td>FIPS 203</td><td>aws-lc-rs</td><td>Yes</td></tr>
<tr><td>AES-256-GCM</td><td>SP 800-38D</td><td>aws-lc-rs</td><td>Yes</td></tr>
<tr><td>HKDF-SHA256</td><td>SP 800-56C</td><td>aws-lc-rs</td><td>Yes</td></tr>
<tr><td>SHA-256</td><td>FIPS 180-4</td><td>aws-lc-rs</td><td>Yes</td></tr>
<tr><td>ML-DSA</td><td>FIPS 204</td><td>fips204</td><td>No</td></tr>
<tr><td>SLH-DSA</td><td>FIPS 205</td><td>fips205</td><td>No</td></tr>
<tr><td>FN-DSA</td><td>FIPS 206 (draft)</td><td>fn-dsa</td><td>No</td></tr>
</tbody></table>
</div><h3 id="unified-api-with-cryptoconfig"><a class="doc-anchor" href="#unified-api-with-cryptoconfig">§</a>Unified API with CryptoConfig</h3>
<p>All cryptographic operations use <a href="unified_api/types/struct.CryptoConfig.html" title="struct latticearc::unified_api::types::CryptoConfig"><code>CryptoConfig</code></a> for configuration. This builder
pattern provides automatic algorithm selection based on use case or security level,
with optional Zero Trust session verification.</p>
<h4 id="basic-usage-hybrid--recommended"><a class="doc-anchor" href="#basic-usage-hybrid--recommended">§</a>Basic Usage (Hybrid — Recommended)</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>latticearc::{encrypt, decrypt, CryptoConfig, EncryptKey, DecryptKey};

<span class="comment">// Hybrid encryption: ML-KEM-768 + X25519 + HKDF + AES-256-GCM
</span><span class="kw">let </span>(pk, sk) = latticearc::generate_hybrid_keypair()<span class="question-mark">?</span>;
<span class="kw">let </span>encrypted = encrypt(<span class="string">b"secret"</span>, EncryptKey::Hybrid(<span class="kw-2">&amp;</span>pk), CryptoConfig::new())<span class="question-mark">?</span>;
<span class="kw">let </span>decrypted = decrypt(<span class="kw-2">&amp;</span>encrypted, DecryptKey::Hybrid(<span class="kw-2">&amp;</span>sk), CryptoConfig::new())<span class="question-mark">?</span>;</code></pre></div><h3 id="digital-signatures"><a class="doc-anchor" href="#digital-signatures">§</a>Digital Signatures</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>latticearc::{generate_signing_keypair, sign_with_key, verify, CryptoConfig};

<span class="kw">let </span>message = <span class="string">b"Document to sign"</span>;

<span class="comment">// Generate a persistent signing keypair (ML-DSA-65 + Ed25519 hybrid)
</span><span class="kw">let </span>(pk, sk, scheme) = generate_signing_keypair(CryptoConfig::new())<span class="question-mark">?</span>;

<span class="comment">// Sign with the persistent keypair
</span><span class="kw">let </span>signed = sign_with_key(message, <span class="kw-2">&amp;</span>sk, <span class="kw-2">&amp;</span>pk, CryptoConfig::new())<span class="question-mark">?</span>;

<span class="comment">// Verify (uses public key embedded in SignedData)
</span><span class="kw">let </span>is_valid = verify(<span class="kw-2">&amp;</span>signed, CryptoConfig::new())<span class="question-mark">?</span>;</code></pre></div><h3 id="feature-flags"><a class="doc-anchor" href="#feature-flags">§</a>Feature Flags</h3><div><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>fips</code></td><td>FIPS 140-3 validated backend via aws-lc-rs. Requires CMake + Go build tools. Without this feature, aws-lc-rs uses its default non-FIPS backend (C compiler only).</td></tr>
<tr><td><code>fips-self-test</code></td><td>Power-up KAT self-tests for all FIPS-boundary algorithms (ML-KEM, AES-GCM, SHA-2, ML-DSA, SLH-DSA).</td></tr>
<tr><td><code>zkp-serde</code></td><td>Serialization support for ZKP types (enables <code>serde_with</code> for Schnorr/Sigma protocol structs).</td></tr>
<tr><td><code>formal-verification</code></td><td>Compilation marker: enables formal verification harness code (Kani proofs). Does not run proofs — use <code>cargo kani</code> separately.</td></tr>
<tr><td><code>kani</code></td><td>Compilation marker: enables Kani bounded model checking proof harnesses. Requires <code>cargo kani</code> to execute proofs.</td></tr>
<tr><td><code>saw</code></td><td>Compilation marker: enables SAW formal verification markers (inherited from aws-lc-rs). Does not run SAW proofs at build time.</td></tr>
</tbody></table>
</div><h3 id="more-examples"><a class="doc-anchor" href="#more-examples">§</a>More Examples</h3><h4 id="symmetric-encryption"><a class="doc-anchor" href="#symmetric-encryption">§</a>Symmetric Encryption</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>latticearc::{encrypt, decrypt, CryptoConfig, CryptoScheme, EncryptKey, DecryptKey};

<span class="kw">let </span>key = [<span class="number">0u8</span>; <span class="number">32</span>];  <span class="comment">// 256-bit key for AES-256-GCM
</span><span class="kw">let </span>encrypted = encrypt(<span class="string">b"secret"</span>, EncryptKey::Symmetric(<span class="kw-2">&amp;</span>key),
    CryptoConfig::new().force_scheme(CryptoScheme::Symmetric))<span class="question-mark">?</span>;
<span class="kw">let </span>decrypted = decrypt(<span class="kw-2">&amp;</span>encrypted, DecryptKey::Symmetric(<span class="kw-2">&amp;</span>key), CryptoConfig::new())<span class="question-mark">?</span>;</code></pre></div><h4 id="with-use-case-selection"><a class="doc-anchor" href="#with-use-case-selection">§</a>With Use Case Selection</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>latticearc::{encrypt, CryptoConfig, UseCase, EncryptKey};

<span class="comment">// Library selects optimal hybrid algorithm for the use case
</span><span class="kw">let </span>(pk, _sk) = latticearc::generate_hybrid_keypair()<span class="question-mark">?</span>;
<span class="kw">let </span>encrypted = encrypt(<span class="string">b"data"</span>, EncryptKey::Hybrid(<span class="kw-2">&amp;</span>pk),
    CryptoConfig::new().use_case(UseCase::FileStorage))<span class="question-mark">?</span>;</code></pre></div><h4 id="zero-trust-session-verification"><a class="doc-anchor" href="#zero-trust-session-verification">§</a>Zero Trust Session Verification</h4>
<p>For production deployments, use <a href="unified_api/zero_trust/struct.VerifiedSession.html" title="struct latticearc::unified_api::zero_trust::VerifiedSession"><code>VerifiedSession</code></a> to enable Zero Trust
verification before each operation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>latticearc::{
    encrypt, decrypt, CryptoConfig, VerifiedSession, generate_keypair,
    EncryptKey, DecryptKey,
};

<span class="comment">// Step 1: Generate a keypair (done once, typically at provisioning)
</span><span class="kw">let </span>(pk, sk) = generate_keypair()<span class="question-mark">?</span>;

<span class="comment">// Step 2: Establish a verified session (performs challenge-response)
</span><span class="kw">let </span>session = VerifiedSession::establish(<span class="kw-2">&amp;</span>pk, sk.as_ref())<span class="question-mark">?</span>;

<span class="comment">// Step 3: Hybrid encryption with session verification
</span><span class="kw">let </span>(enc_pk, enc_sk) = latticearc::generate_hybrid_keypair()<span class="question-mark">?</span>;
<span class="kw">let </span>encrypted = encrypt(<span class="string">b"secret"</span>, EncryptKey::Hybrid(<span class="kw-2">&amp;</span>enc_pk),
    CryptoConfig::new().session(<span class="kw-2">&amp;</span>session))<span class="question-mark">?</span>;
<span class="kw">let </span>decrypted = decrypt(<span class="kw-2">&amp;</span>encrypted, DecryptKey::Hybrid(<span class="kw-2">&amp;</span>enc_sk),
    CryptoConfig::new().session(<span class="kw-2">&amp;</span>session))<span class="question-mark">?</span>;</code></pre></div><h4 id="hybrid-encryption-ml-kem-768--x25519"><a class="doc-anchor" href="#hybrid-encryption-ml-kem-768--x25519">§</a>Hybrid Encryption (ML-KEM-768 + X25519)</h4>
<p>Use the unified API with <code>EncryptKey::Hybrid</code> / <code>DecryptKey::Hybrid</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>latticearc::{encrypt, decrypt, CryptoConfig, EncryptKey, DecryptKey};

<span class="kw">let </span>(pk, sk) = latticearc::generate_hybrid_keypair()<span class="question-mark">?</span>;
<span class="kw">let </span>encrypted = encrypt(<span class="string">b"secret data"</span>, EncryptKey::Hybrid(<span class="kw-2">&amp;</span>pk), CryptoConfig::new())<span class="question-mark">?</span>;
<span class="kw">let </span>decrypted = decrypt(<span class="kw-2">&amp;</span>encrypted, DecryptKey::Hybrid(<span class="kw-2">&amp;</span>sk), CryptoConfig::new())<span class="question-mark">?</span>;</code></pre></div><h4 id="hybrid-signatures-ml-dsa-65--ed25519"><a class="doc-anchor" href="#hybrid-signatures-ml-dsa-65--ed25519">§</a>Hybrid Signatures (ML-DSA-65 + Ed25519)</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>latticearc::{generate_hybrid_signing_keypair, sign_hybrid, verify_hybrid_signature, SecurityMode};

<span class="comment">// Generate a hybrid signing keypair (ML-DSA-65 + Ed25519)
</span><span class="kw">let </span>(pk, sk) = generate_hybrid_signing_keypair(SecurityMode::Unverified)<span class="question-mark">?</span>;

<span class="comment">// Sign (both ML-DSA and Ed25519 signatures generated)
</span><span class="kw">let </span>signature = sign_hybrid(<span class="string">b"document"</span>, <span class="kw-2">&amp;</span>sk, SecurityMode::Unverified)<span class="question-mark">?</span>;

<span class="comment">// Verify (both must pass for signature to be valid)
</span><span class="kw">let </span>valid = verify_hybrid_signature(<span class="string">b"document"</span>, <span class="kw-2">&amp;</span>signature, <span class="kw-2">&amp;</span>pk, SecurityMode::Unverified)<span class="question-mark">?</span>;</code></pre></div><h4 id="session-lifecycle"><a class="doc-anchor" href="#session-lifecycle">§</a>Session Lifecycle</h4>
<p>Sessions have a 30-minute default lifetime:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>latticearc::{encrypt, CryptoConfig, VerifiedSession, generate_keypair, CoreError, EncryptKey};

<span class="kw">let </span>(pk, sk) = generate_keypair()<span class="question-mark">?</span>;
<span class="kw">let </span>session = VerifiedSession::establish(<span class="kw-2">&amp;</span>pk, sk.as_ref())<span class="question-mark">?</span>;

<span class="comment">// Check session properties
</span><span class="macro">assert!</span>(session.is_valid());  <span class="comment">// Not expired
</span><span class="kw">let _ </span>= session.session_id(); <span class="comment">// Unique ID for audit
</span><span class="kw">let _ </span>= session.expires_at(); <span class="comment">// Expiration time

// Validate before critical operations
</span>session.verify_valid()<span class="question-mark">?</span>;  <span class="comment">// Returns Err(SessionExpired) if expired

// Refresh if expired
</span><span class="kw">if </span>!session.is_valid() {
    <span class="kw">let </span>new_session = VerifiedSession::establish(<span class="kw-2">&amp;</span>pk, sk.as_ref())<span class="question-mark">?</span>;
}</code></pre></div><h4 id="complete-example"><a class="doc-anchor" href="#complete-example">§</a>Complete Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>latticearc::{
    encrypt, decrypt, generate_signing_keypair, sign_with_key, verify,
    generate_hybrid_keypair, CryptoConfig, CoreError,
    EncryptKey, DecryptKey,
};

<span class="kw">fn </span>secure_workflow() -&gt; <span class="prelude-ty">Result</span>&lt;(), CoreError&gt; {
    <span class="comment">// --- Hybrid Encryption (unified API) ---
    </span><span class="kw">let </span>(enc_pk, enc_sk) = generate_hybrid_keypair()<span class="question-mark">?</span>;
    <span class="kw">let </span>encrypted = encrypt(<span class="string">b"confidential"</span>, EncryptKey::Hybrid(<span class="kw-2">&amp;</span>enc_pk),
        CryptoConfig::new())<span class="question-mark">?</span>;
    <span class="kw">let </span>decrypted = decrypt(<span class="kw-2">&amp;</span>encrypted, DecryptKey::Hybrid(<span class="kw-2">&amp;</span>enc_sk),
        CryptoConfig::new())<span class="question-mark">?</span>;

    <span class="comment">// --- Digital Signatures ---
    </span><span class="kw">let </span>(sign_pk, sign_sk, _scheme) = generate_signing_keypair(CryptoConfig::new())<span class="question-mark">?</span>;
    <span class="kw">let </span>signed = sign_with_key(<span class="string">b"important document"</span>, <span class="kw-2">&amp;</span>sign_sk, <span class="kw-2">&amp;</span>sign_pk, CryptoConfig::new())<span class="question-mark">?</span>;
    <span class="kw">let </span>is_valid = verify(<span class="kw-2">&amp;</span>signed, CryptoConfig::new())<span class="question-mark">?</span>;
    <span class="macro">assert!</span>(is_valid);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div></div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><dl class="item-table reexports"><dt id="reexport.core"><code>pub use <a class="mod" href="unified_api/index.html" title="mod latticearc::unified_api">unified_api</a> as core;</code></dt><dt id="reexport.LatticeArcError"><code>pub use prelude::prelude::<a class="enum" href="prelude/prelude/error/types/enum.LatticeArcError.html" title="enum latticearc::prelude::prelude::error::types::LatticeArcError">LatticeArcError</a>;</code></dt><dt id="reexport.AlgorithmSelection"><code>pub use unified_api::<a class="enum" href="types/types/enum.AlgorithmSelection.html" title="enum latticearc::types::types::AlgorithmSelection">AlgorithmSelection</a>;</code></dt><dt id="reexport.Challenge"><code>pub use unified_api::<a class="struct" href="unified_api/zero_trust/struct.Challenge.html" title="struct latticearc::unified_api::zero_trust::Challenge">Challenge</a>;</code></dt><dt id="reexport.ComplianceMode"><code>pub use unified_api::<a class="enum" href="types/types/enum.ComplianceMode.html" title="enum latticearc::types::types::ComplianceMode">ComplianceMode</a>;</code></dt><dt id="reexport.ContinuousSession"><code>pub use unified_api::<a class="struct" href="unified_api/zero_trust/struct.ContinuousSession.html" title="struct latticearc::unified_api::zero_trust::ContinuousSession">ContinuousSession</a>;</code></dt><dt id="reexport.ContinuousVerifiable"><code>pub use unified_api::<a class="trait" href="types/traits/trait.ContinuousVerifiable.html" title="trait latticearc::types::traits::ContinuousVerifiable">ContinuousVerifiable</a>;</code></dt><dt id="reexport.CoreError"><code>pub use unified_api::<a class="enum" href="unified_api/error/enum.CoreError.html" title="enum latticearc::unified_api::error::CoreError">CoreError</a>;</code></dt><dt id="reexport.CryptoConfig"><code>pub use unified_api::<a class="struct" href="unified_api/types/struct.CryptoConfig.html" title="struct latticearc::unified_api::types::CryptoConfig">CryptoConfig</a>;</code></dt><dt id="reexport.CryptoContext"><code>pub use unified_api::<a class="struct" href="types/types/struct.CryptoContext.html" title="struct latticearc::types::types::CryptoContext">CryptoContext</a>;</code></dt><dt id="reexport.CryptoPayload"><code>pub use unified_api::<a class="struct" href="types/types/struct.CryptoPayload.html" title="struct latticearc::types::types::CryptoPayload">CryptoPayload</a>;</code></dt><dt id="reexport.CryptoScheme"><code>pub use unified_api::<a class="enum" href="types/types/enum.CryptoScheme.html" title="enum latticearc::types::types::CryptoScheme">CryptoScheme</a>;</code></dt><dt id="reexport.DataCharacteristics"><code>pub use unified_api::<a class="struct" href="types/traits/struct.DataCharacteristics.html" title="struct latticearc::types::traits::DataCharacteristics">DataCharacteristics</a>;</code></dt><dt id="reexport.DecryptKey"><code>pub use unified_api::<a class="enum" href="types/crypto_types/enum.DecryptKey.html" title="enum latticearc::types::crypto_types::DecryptKey">DecryptKey</a>;</code></dt><dt id="reexport.Decryptable"><code>pub use unified_api::<a class="trait" href="types/traits/trait.Decryptable.html" title="trait latticearc::types::traits::Decryptable">Decryptable</a>;</code></dt><dt id="reexport.EncryptKey"><code>pub use unified_api::<a class="enum" href="types/crypto_types/enum.EncryptKey.html" title="enum latticearc::types::crypto_types::EncryptKey">EncryptKey</a>;</code></dt><dt id="reexport.Encryptable"><code>pub use unified_api::<a class="trait" href="types/traits/trait.Encryptable.html" title="trait latticearc::types::traits::Encryptable">Encryptable</a>;</code></dt><dt id="reexport.EncryptedData"><code>pub use unified_api::<a class="type" href="types/types/type.EncryptedData.html" title="type latticearc::types::types::EncryptedData">EncryptedData</a>;</code></dt><dt id="reexport.EncryptedMetadata"><code>pub use unified_api::<a class="struct" href="types/types/struct.EncryptedMetadata.html" title="struct latticearc::types::types::EncryptedMetadata">EncryptedMetadata</a>;</code></dt><dt id="reexport.EncryptedOutput"><code>pub use unified_api::<a class="struct" href="types/crypto_types/struct.EncryptedOutput.html" title="struct latticearc::types::crypto_types::EncryptedOutput">EncryptedOutput</a>;</code></dt><dt id="reexport.EncryptionScheme"><code>pub use unified_api::<a class="enum" href="types/crypto_types/enum.EncryptionScheme.html" title="enum latticearc::types::crypto_types::EncryptionScheme">EncryptionScheme</a>;</code></dt><dt id="reexport.HardwareAccelerator"><code>pub use unified_api::<a class="trait" href="types/traits/trait.HardwareAccelerator.html" title="trait latticearc::types::traits::HardwareAccelerator">HardwareAccelerator</a>;</code></dt><dt id="reexport.HardwareAware"><code>pub use unified_api::<a class="trait" href="types/traits/trait.HardwareAware.html" title="trait latticearc::types::traits::HardwareAware">HardwareAware</a>;</code></dt><dt id="reexport.HardwareCapabilities"><code>pub use unified_api::<a class="struct" href="types/traits/struct.HardwareCapabilities.html" title="struct latticearc::types::traits::HardwareCapabilities">HardwareCapabilities</a>;</code></dt><dt id="reexport.HardwareInfo"><code>pub use unified_api::<a class="struct" href="types/traits/struct.HardwareInfo.html" title="struct latticearc::types::traits::HardwareInfo">HardwareInfo</a>;</code></dt><dt id="reexport.HardwareType"><code>pub use unified_api::<a class="enum" href="types/traits/enum.HardwareType.html" title="enum latticearc::types::traits::HardwareType">HardwareType</a>;</code></dt><dt id="reexport.HashOutput"><code>pub use unified_api::<a class="type" href="types/types/type.HashOutput.html" title="type latticearc::types::types::HashOutput">HashOutput</a>;</code></dt><dt id="reexport.HybridComponents"><code>pub use unified_api::<a class="struct" href="types/crypto_types/struct.HybridComponents.html" title="struct latticearc::types::crypto_types::HybridComponents">HybridComponents</a>;</code></dt><dt id="reexport.KeyDerivable"><code>pub use unified_api::<a class="trait" href="types/traits/trait.KeyDerivable.html" title="trait latticearc::types::traits::KeyDerivable">KeyDerivable</a>;</code></dt><dt id="reexport.KeyPair"><code>pub use unified_api::<a class="struct" href="types/types/struct.KeyPair.html" title="struct latticearc::types::types::KeyPair">KeyPair</a>;</code></dt><dt id="reexport.PatternType"><code>pub use unified_api::<a class="enum" href="types/traits/enum.PatternType.html" title="enum latticearc::types::traits::PatternType">PatternType</a>;</code></dt><dt id="reexport.PerformancePreference"><code>pub use unified_api::<a class="enum" href="types/types/enum.PerformancePreference.html" title="enum latticearc::types::types::PerformancePreference">PerformancePreference</a>;</code></dt><dt id="reexport.PrivateKey"><code>pub use unified_api::<a class="type" href="types/types/type.PrivateKey.html" title="type latticearc::types::types::PrivateKey">PrivateKey</a>;</code></dt><dt id="reexport.ProofOfPossession"><code>pub use unified_api::<a class="trait" href="types/traits/trait.ProofOfPossession.html" title="trait latticearc::types::traits::ProofOfPossession">ProofOfPossession</a>;</code></dt><dt id="reexport.ProofOfPossessionData"><code>pub use unified_api::<a class="struct" href="unified_api/zero_trust/struct.ProofOfPossessionData.html" title="struct latticearc::unified_api::zero_trust::ProofOfPossessionData">ProofOfPossessionData</a>;</code></dt><dt id="reexport.PublicKey"><code>pub use unified_api::<a class="type" href="types/types/type.PublicKey.html" title="type latticearc::types::types::PublicKey">PublicKey</a>;</code></dt><dt id="reexport.Result"><code>pub use unified_api::<a class="type" href="unified_api/error/type.Result.html" title="type latticearc::unified_api::error::Result">Result</a>;</code></dt><dt id="reexport.SchemeSelector"><code>pub use unified_api::<a class="trait" href="types/traits/trait.SchemeSelector.html" title="trait latticearc::types::traits::SchemeSelector">SchemeSelector</a>;</code></dt><dt id="reexport.SecurityLevel"><code>pub use unified_api::<a class="enum" href="types/types/enum.SecurityLevel.html" title="enum latticearc::types::types::SecurityLevel">SecurityLevel</a>;</code></dt><dt id="reexport.SecurityMode"><code>pub use unified_api::<a class="enum" href="unified_api/zero_trust/enum.SecurityMode.html" title="enum latticearc::unified_api::zero_trust::SecurityMode">SecurityMode</a>;</code></dt><dt id="reexport.Signable"><code>pub use unified_api::<a class="trait" href="types/traits/trait.Signable.html" title="trait latticearc::types::traits::Signable">Signable</a>;</code></dt><dt id="reexport.SignedData"><code>pub use unified_api::<a class="type" href="types/types/type.SignedData.html" title="type latticearc::types::types::SignedData">SignedData</a>;</code></dt><dt id="reexport.SignedMetadata"><code>pub use unified_api::<a class="struct" href="types/types/struct.SignedMetadata.html" title="struct latticearc::types::types::SignedMetadata">SignedMetadata</a>;</code></dt><dt id="reexport.SymmetricKey"><code>pub use unified_api::<a class="type" href="types/types/type.SymmetricKey.html" title="type latticearc::types::types::SymmetricKey">SymmetricKey</a>;</code></dt><dt id="reexport.TrustLevel"><code>pub use unified_api::<a class="enum" href="types/zero_trust/enum.TrustLevel.html" title="enum latticearc::types::zero_trust::TrustLevel">TrustLevel</a>;</code></dt><dt id="reexport.UseCase"><code>pub use unified_api::<a class="enum" href="types/types/enum.UseCase.html" title="enum latticearc::types::types::UseCase">UseCase</a>;</code></dt><dt id="reexport.VERSION"><code>pub use unified_api::<a class="constant" href="unified_api/constant.VERSION.html" title="constant latticearc::unified_api::VERSION">VERSION</a>;</code></dt><dt id="reexport.Verifiable"><code>pub use unified_api::<a class="trait" href="types/traits/trait.Verifiable.html" title="trait latticearc::types::traits::Verifiable">Verifiable</a>;</code></dt><dt id="reexport.VerificationStatus"><code>pub use unified_api::<a class="enum" href="types/traits/enum.VerificationStatus.html" title="enum latticearc::types::traits::VerificationStatus">VerificationStatus</a>;</code></dt><dt id="reexport.VerifiedSession"><code>pub use unified_api::<a class="struct" href="unified_api/zero_trust/struct.VerifiedSession.html" title="struct latticearc::unified_api::zero_trust::VerifiedSession">VerifiedSession</a>;</code></dt><dt id="reexport.ZeroKnowledgeProof"><code>pub use unified_api::<a class="struct" href="unified_api/zero_trust/struct.ZeroKnowledgeProof.html" title="struct latticearc::unified_api::zero_trust::ZeroKnowledgeProof">ZeroKnowledgeProof</a>;</code></dt><dt id="reexport.ZeroTrustAuth"><code>pub use unified_api::<a class="struct" href="unified_api/zero_trust/struct.ZeroTrustAuth.html" title="struct latticearc::unified_api::zero_trust::ZeroTrustAuth">ZeroTrustAuth</a>;</code></dt><dt id="reexport.ZeroTrustAuthenticable"><code>pub use unified_api::<a class="trait" href="types/traits/trait.ZeroTrustAuthenticable.html" title="trait latticearc::types::traits::ZeroTrustAuthenticable">ZeroTrustAuthenticable</a>;</code></dt><dt id="reexport.ZeroTrustSession"><code>pub use unified_api::<a class="struct" href="unified_api/zero_trust/struct.ZeroTrustSession.html" title="struct latticearc::unified_api::zero_trust::ZeroTrustSession">ZeroTrustSession</a>;</code></dt><dt id="reexport.ZeroizedBytes"><code>pub use unified_api::<a class="struct" href="types/types/struct.ZeroizedBytes.html" title="struct latticearc::types::types::ZeroizedBytes">ZeroizedBytes</a>;</code></dt><dt id="reexport.fips_available"><code>pub use unified_api::<a class="fn" href="types/types/fn.fips_available.html" title="fn latticearc::types::types::fips_available">fips_available</a>;</code></dt><dt id="reexport.init"><code>pub use unified_api::<a class="fn" href="unified_api/fn.init.html" title="fn latticearc::unified_api::init">init</a>;</code></dt><dt id="reexport.init_with_config"><code>pub use unified_api::<a class="fn" href="unified_api/fn.init_with_config.html" title="fn latticearc::unified_api::init_with_config">init_with_config</a>;</code></dt><dt id="reexport.decrypt"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.decrypt.html" title="fn latticearc::unified_api::convenience::decrypt">decrypt</a>;</code></dt><dt id="reexport.encrypt"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.encrypt.html" title="fn latticearc::unified_api::convenience::encrypt">encrypt</a>;</code></dt><dt id="reexport.generate_signing_keypair"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.generate_signing_keypair.html" title="fn latticearc::unified_api::convenience::generate_signing_keypair">generate_signing_keypair</a>;</code></dt><dt id="reexport.sign_with_key"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.sign_with_key.html" title="fn latticearc::unified_api::convenience::sign_with_key">sign_with_key</a>;</code></dt><dt id="reexport.verify"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.verify.html" title="fn latticearc::unified_api::convenience::verify">verify</a>;</code></dt><dt id="reexport.generate_hybrid_keypair"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.generate_hybrid_keypair.html" title="fn latticearc::unified_api::convenience::generate_hybrid_keypair">generate_hybrid_keypair</a>;</code></dt><dt id="reexport.generate_hybrid_keypair_with_level"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.generate_hybrid_keypair_with_level.html" title="fn latticearc::unified_api::convenience::generate_hybrid_keypair_with_level">generate_hybrid_keypair_with_level</a>;</code></dt><dt id="reexport.generate_hybrid_signing_keypair"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.generate_hybrid_signing_keypair.html" title="fn latticearc::unified_api::convenience::generate_hybrid_signing_keypair">generate_hybrid_signing_keypair</a>;</code></dt><dt id="reexport.generate_hybrid_signing_keypair_with_config"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.generate_hybrid_signing_keypair_with_config.html" title="fn latticearc::unified_api::convenience::generate_hybrid_signing_keypair_with_config">generate_hybrid_signing_keypair_with_config</a>;</code></dt><dt id="reexport.sign_hybrid"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.sign_hybrid.html" title="fn latticearc::unified_api::convenience::sign_hybrid">sign_hybrid</a>;</code></dt><dt id="reexport.sign_hybrid_with_config"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.sign_hybrid_with_config.html" title="fn latticearc::unified_api::convenience::sign_hybrid_with_config">sign_hybrid_with_config</a>;</code></dt><dt id="reexport.verify_hybrid_signature"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.verify_hybrid_signature.html" title="fn latticearc::unified_api::convenience::verify_hybrid_signature">verify_hybrid_signature</a>;</code></dt><dt id="reexport.verify_hybrid_signature_with_config"><code>pub use unified_api::<a class="fn" href="unified_api/convenience/fn.verify_hybrid_signature_with_config.html" title="fn latticearc::unified_api::convenience::verify_hybrid_signature_with_config">verify_hybrid_signature_with_config</a>;</code></dt><dt id="reexport.TlsConfig"><code>pub use tls::<a class="struct" href="tls/struct.TlsConfig.html" title="struct latticearc::tls::TlsConfig">TlsConfig</a>;</code></dt><dt id="reexport.TlsConstraints"><code>pub use tls::<a class="struct" href="tls/selector/struct.TlsConstraints.html" title="struct latticearc::tls::selector::TlsConstraints">TlsConstraints</a>;</code></dt><dt id="reexport.TlsContext"><code>pub use tls::<a class="struct" href="tls/selector/struct.TlsContext.html" title="struct latticearc::tls::selector::TlsContext">TlsContext</a>;</code></dt><dt id="reexport.TlsMode"><code>pub use tls::<a class="enum" href="tls/enum.TlsMode.html" title="enum latticearc::tls::TlsMode">TlsMode</a>;</code></dt><dt id="reexport.TlsPolicyEngine"><code>pub use tls::<a class="struct" href="tls/selector/struct.TlsPolicyEngine.html" title="struct latticearc::tls::selector::TlsPolicyEngine">TlsPolicyEngine</a>;</code></dt><dt id="reexport.TlsUseCase"><code>pub use tls::<a class="enum" href="tls/selector/enum.TlsUseCase.html" title="enum latticearc::tls::selector::TlsUseCase">TlsUseCase</a>;</code></dt><dt id="reexport.tls_accept"><code>pub use tls::<a class="fn" href="tls/basic_features/fn.tls_accept.html" title="fn latticearc::tls::basic_features::tls_accept">tls_accept</a>;</code></dt><dt id="reexport.tls_connect"><code>pub use tls::<a class="fn" href="tls/basic_features/fn.tls_connect.html" title="fn latticearc::tls::basic_features::tls_connect">tls_connect</a>;</code></dt></dl><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="hybrid/index.html" title="mod latticearc::hybrid">hybrid</a></dt><dd>Hybrid cryptography combining post-quantum and classical algorithms.
Hybrid Cryptography for LatticeArc</dd><dt><a class="mod" href="perf/index.html" title="mod latticearc::perf">perf</a></dt><dd>Performance monitoring and benchmarking utilities.
LatticeArc Performance Primitives</dd><dt><a class="mod" href="prelude/index.html" title="mod latticearc::prelude">prelude</a></dt><dd>Common prelude with error handling, domain constants, and testing infrastructure.
LatticeArc Prelude Crate</dd><dt><a class="mod" href="primitives/index.html" title="mod latticearc::primitives">primitives</a></dt><dd>Core cryptographic primitives (KEM, signatures, AEAD, hash, KDF, MAC).</dd><dt><a class="mod" href="tls/index.html" title="mod latticearc::tls">tls</a></dt><dd>TLS 1.3 with post-quantum key exchange support.</dd><dt><a class="mod" href="types/index.html" title="mod latticearc::types">types</a></dt><dd>Pure-Rust domain types, traits, configuration, and policy engine.</dd><dt><a class="mod" href="unified_api/index.html" title="mod latticearc::unified_api">unified_<wbr>api</a></dt><dd>Unified cryptographic API with Zero-Trust security.</dd></dl><script type="text/json" id="notable-traits-data">{"&<Vec<T, A> as Index<I>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div>","&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>]</div>","&mut <Vec<T, A> as Index<I>>::Output":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div>","<Vec<T, A> as IntoIterator>::IntoIter":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div>","<Vec<T> as IntoDeserializer<'de, E>>::Deserializer":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div>","<Vec<T> as IntoParallelIterator>::Iter":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div>","Vec<u8>":"<h3>Notable traits for <code><a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;</code></h3><pre><code><div class=\"where\">impl&lt;A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/1.93.1/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.93.1/std/primitive.u8.html\">u8</a>, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.93.1/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></div>"}</script></section></div></main></body></html>